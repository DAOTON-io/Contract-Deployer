(int, slice, slice, cell,cell ,int,cell) load_data() inline {
  var ds = get_data().begin_parse();
 
  ;; "1,2,3,4,5,6,7"
  int dao_type = ds~load_uint(16);

  slice token_contract =  ds~load_msg_addr();
  slice nft_contract =  ds~load_msg_addr();
  cell content = ds~load_ref();
  cell proposals_ref = ds~load_ref();

  ds.end_parse();

  ;; Parse proposals
  ds = proposals_ref.begin_parse();
  int proposals_seq = ds~load_uint(32);
  cell proposals_dict = ds~load_dict();
  ;; proposals_ids = ds~load_dict();
  ds.end_parse();

return (dao_type, token_contract, nft_contract,content, proposals_ref ,proposals_seq, proposals_dict);

   
}

() save_data(int dao_type ,slice token_contract, slice nft_contract ,cell content, cell proposals) impure inline {
  set_data(begin_cell()
    .store_uint(dao_type, 16)
    .store_slice(token_contract)
    .store_slice(nft_contract)
    .store_ref(content)
    .store_ref(proposals)
    .end_cell());
}

(cell) create_proposal(int timestamp ,int threshold_success ,int threshold_fail ,cell proposals_dict,int proposals_seq) impure { 
    ;; Serialize proposal
    var container = begin_cell()
        .store_coins(0) ;; yes count
        .store_coins(0) ;; no count
        .store_coins(0) ;; abstain count
        .store_uint(timestamp,64) ;; expire time
        .store_ref(begin_cell()
            .store_coins(threshold_success)
            .store_coins(threshold_fail)
        .end_cell())
        .store_dict(null())
        .end_cell();

    ;; Store ref
    var data = begin_cell().store_ref(container);

    var dict =  udict_set_builder(proposals_dict, 32, proposals_seq + 1 , data);

  return begin_cell().store_ref(begin_cell()
            .store_uint(proposals_seq + 1, 32)
            .store_dict(dict)
        .end_cell()).end_cell();
}

;; init state
() recv_internal(cell in_msg_cell, slice in_msg_body) impure {
  var (dao_type, token_contract, nft_contract, content ,proposals_ref, proposals_seq, proposals_dict  ) = load_data();

  ;;  Get sender address
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);
  slice s_addr = cs~load_msg_addr();
  (int sender_wc, slice sender_addr) = parse_var_addr(s_addr);
  int member = sender_addr~load_uint(256);

 
  if (in_msg_body.slice_empty?()) { ;; empty body
      save_data(dao_type, token_contract, nft_contract,content, proposals_ref);
  }
  else {
  
  int op = in_msg_body~load_uint(32);

 ;; op1 = create proposal
  if(op == 1){
   int time = in_msg_body~load_uint(64); ;; timestamp
   int success_threshold = in_msg_body~load_uint(32); ;; success_threshold
   int fail_threshold = in_msg_body~load_uint(32); ;; fail_threshold

   var proposal = create_proposal(time, success_threshold, fail_threshold , proposals_dict , proposals_seq);

   save_data(dao_type, token_contract, nft_contract, content , proposal);
  }
  if(op == 2){

  }
  if(op == 3){

  }

  }

}

(int,int,int) get_proposal(int id) method_id {
  var (dao_type, token_contract, nft_contract, content ,proposals_ref,proposals_seq, proposals_dict  ) = load_data();

   var (itm, found) = proposals_dict.udict_get?(32, id);

    var cl = itm~load_ref();
    itm.end_parse();
    var cs = cl.begin_parse();

    ;; Read
    int proposal_voted_yes = cs~load_coins();
    int proposal_voted_no = cs~load_coins();
    int proposal_voted_abstain = cs~load_coins();

   return (proposal_voted_yes,proposal_voted_no,proposal_voted_abstain);
 }

(int, slice, slice ,cell,int) get_dao_data() method_id {
   var (dao_type, token_contract, nft_contract, content ,proposals_ref,proposals_seq, proposals_dict) = load_data();

   return (dao_type, token_contract, nft_contract,content,proposals_seq);
 }
